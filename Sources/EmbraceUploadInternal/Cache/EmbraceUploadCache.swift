//
//  Copyright Â© 2024 Embrace Mobile, Inc. All rights reserved.
//

import Foundation
import EmbraceOTelInternal
import GRDB

/// Class that handles all the cached upload data generated by the Embrace SDK.
class EmbraceUploadCache {

    private(set) var options: EmbraceUpload.CacheOptions
    private(set) var dbQueue: DatabaseQueue

    init(options: EmbraceUpload.CacheOptions) throws {
        self.options = options

        // create base directory if necessary
        try FileManager.default.createDirectory(at: options.cacheBaseUrl, withIntermediateDirectories: true)

        // create sqlite file
        dbQueue = try DatabaseQueue(path: options.cacheFilePath)

        // define tables
        try dbQueue.write { db in
            try UploadDataRecord.defineTable(db: db)
        }

        try clearStaleDataIfNeeded()
    }

    /// Fetches the cached upload data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    /// - Returns: The cached `UploadDataRecord`, if any
    public func fetchUploadData(id: String, type: EmbraceUploadType) throws -> UploadDataRecord? {
        try dbQueue.read { db in
            return try UploadDataRecord.fetchOne(db, key: ["id": id, "type": type.rawValue])
        }
    }

    /// Fetches all the cached upload data.
    /// - Returns: An array containing all the cached `UploadDataRecords`
    public func fetchAllUploadData() throws -> [UploadDataRecord] {
        try dbQueue.read { db in
            return try UploadDataRecord
                .order(Column("date").asc)
                .fetchAll(db)
        }
    }

    /// Removes stale data based on size or date, if they're limited in options.
    @discardableResult public func clearStaleDataIfNeeded() throws -> UInt {
        let limitDays = options.cacheDaysLimit
        let limitSize = options.cacheSizeLimit
        let recordsBasedOnDate = limitDays > 0 ? try fetchRecordsToDeleteBasedOnDate(maxDays: limitDays) : []
        let recordsBasedOnSize = limitSize > 0 ? try fetchRecordsToDeleteBasedOnSize(maxSize: limitSize) : []

        let recordsToDelete = Array(Set(recordsBasedOnDate + recordsBasedOnSize))

        let deleteCount = recordsToDelete.count

        if deleteCount > 0 {
            let span = EmbraceOTel().buildSpan(
                name: "emb-upload-cache-vacuum",
                type: .performance,
                attributes: ["removed": "\(deleteCount)"])
                .markAsPrivate()
            span.setStartTime(time: Date())
            let startedSpan = span.startSpan()
            try deleteRecords(recordIDs: recordsToDelete)
            try dbQueue.vacuum()
            startedSpan.end()

            return UInt(deleteCount)
        }

        return 0
    }

    /// Saves the given upload data to the cache.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    ///   - data: Data to cache
    /// - Returns: The newly cached `UploadDataRecord`
    @discardableResult func saveUploadData(id: String, type: EmbraceUploadType, data: Data) throws -> UploadDataRecord {
        let record = UploadDataRecord(id: id, type: type.rawValue, data: data, attemptCount: 0, date: Date())
        try saveUploadData(record)

        return record
    }

    /// Saves the given `UploadDataRecord` to the cache.
    /// - Parameter record: `UploadDataRecord` instance to save
    func saveUploadData(_ record: UploadDataRecord) throws {
        try dbQueue.write { [weak self] db in

            // update if its already stored
            if try record.exists(db) {
                try record.update(db)
                return
            }

            // check limit and delete if necessary
            if let limit = self?.options.cacheLimit, limit > 0 {
                let count = try UploadDataRecord.fetchCount(db)

                if count >= limit {
                    let recordsToDelete = try UploadDataRecord
                        .order(Column("date").asc)
                        .limit(Int(limit))
                        .fetchAll(db)

                    for recordToDelete in recordsToDelete {
                        try recordToDelete.delete(db)
                    }
                }
            }

            try record.insert(db)
        }
    }

    /// Deletes the cached data for the given identifier.
    /// - Parameters:
    ///   - id: Identifiar of the data
    ///   - type: Type of the data
    /// - Returns: Boolean indicating if the data was successfuly deleted
    @discardableResult func deleteUploadData(id: String, type: EmbraceUploadType) throws -> Bool {
        guard let uploadData = try fetchUploadData(id: id, type: type) else {
            return false
        }

        return try deleteUploadData(uploadData)
    }

    /// Deletes the cached `UploadDataRecord`.
    /// - Parameter uploadData: `UploadDataRecord` to delete
    /// - Returns: Boolean indicating if the data was successfuly deleted
    func deleteUploadData(_ uploadData: UploadDataRecord) throws -> Bool {
        try dbQueue.write { db in
            return try uploadData.delete(db)
        }
    }

    /// Updates the attempt count of the upload data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    ///   - attemptCount: New attempt count
    /// - Returns: Returns the updated `UploadDataRecord`, if any
    func updateAttemptCount(
        id: String,
        type: EmbraceUploadType,
        attemptCount: Int
    ) throws {
        try dbQueue.write { db in
            let filter = UploadDataRecord.Schema.id == id && UploadDataRecord.Schema.type == type
            try UploadDataRecord.filter(filter)
                .updateAll(db, UploadDataRecord.Schema.attemptCount.set(to: attemptCount))
        }
    }

    /// Sorts Upload Cache by descending order and goes through it adding the space taken by each record.
    /// Once the __maxSize__ has been reached, all the following record IDs will be returned indicating those need to be deleted.
    /// - Parameter maxSize: The maximum allowed size in bytes for the Database.
    /// - Returns: An array of IDs of the oldest records which are making the DB go above the target maximum size.
    func fetchRecordsToDeleteBasedOnSize(maxSize: UInt) throws -> [String] {
        let sqlQuery = """
        WITH t AS (SELECT id, date, SUM(LENGTH(data)) OVER (ORDER BY date DESC,id) total_size FROM uploads)
        SELECT id FROM t WHERE total_size>=\(maxSize) ORDER BY date DESC;
        """

        var result: [String] = []

        try dbQueue.read { db in
            result = try String.fetchAll(db, sql: sqlQuery)
        }

        return result
    }

    /// Fetches all records that should be deleted based on them being older than __maxDays__ days
    /// - Parameter db: The database where to pull the data from, assumes the records to be UploadDataRecord.
    /// - Parameter maxDays: The maximum allowed days old a record is allowed to be cached.
    /// - Returns: An array of IDs from records that should be deleted.
    func fetchRecordsToDeleteBasedOnDate(maxDays: UInt) throws -> [String] {
        let sqlQuery = """
        SELECT id, date FROM uploads WHERE date <= DATE(DATE(), '-\(maxDays) day')
        """

        var result: [String] = []

        try dbQueue.read { db in
            result = try String.fetchAll(db, sql: sqlQuery)
        }

        return result
    }

    /// Deletes requested records from the database based on their IDs
    /// Assumes the records to be of type __UploadDataRecord__
    /// - Parameter recordIDs: The IDs array to delete
    func deleteRecords(recordIDs: [String]) throws {
        let questionMarks = "\(databaseQuestionMarks(count: recordIDs.count))"
        let sqlQuery = "DELETE FROM uploads WHERE id IN (\(questionMarks))"
        try dbQueue.write { db in
            try db.execute(sql: sqlQuery, arguments: .init(recordIDs))
        }
    }
}
