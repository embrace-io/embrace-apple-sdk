//
//  Copyright Â© 2024 Embrace Mobile, Inc. All rights reserved.
//

import Foundation
#if !EMBRACE_COCOAPOD_BUILDING_SDK
import EmbraceOTelInternal
import EmbraceCommonInternal
import EmbraceCoreDataInternal
#endif
import CoreData

/// Class that handles all the cached upload data generated by the Embrace SDK.
class EmbraceUploadCache {

    private(set) var options: EmbraceUpload.CacheOptions
    let coreData: CoreDataWrapper
    let logger: InternalLogger

    init(options: EmbraceUpload.CacheOptions, logger: InternalLogger) throws {
        self.options = options
        self.logger = logger

        // remove old GRDB sqlite file
        if let url = options.storageMechanism.baseUrl?.appendingPathComponent("db.sqlite") {
            try? FileManager.default.removeItem(at: url)
        }

        // create core data stack
        let coreDataOptions = CoreDataWrapper.Options(
            storageMechanism: options.storageMechanism,
            entities: [UploadDataRecord.entityDescription]
        )
        self.coreData = try CoreDataWrapper(options: coreDataOptions, logger: logger)
    }

    /// Fetches the cached upload data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    /// - Returns: The cached `UploadDataRecord`, if any
    public func fetchUploadData(id: String, type: EmbraceUploadType) -> UploadDataRecord? {
        let request = NSFetchRequest<UploadDataRecord>(entityName: UploadDataRecord.entityName)
        request.predicate = NSPredicate(format: "id == %@ AND type == %i", id, type.rawValue)

        return coreData.fetch(withRequest: request).first
    }

    /// Fetches all the cached upload data.
    /// - Returns: An array containing all the cached `UploadDataRecords`
    public func fetchAllUploadData() -> [UploadDataRecord] {
        let request = NSFetchRequest<UploadDataRecord>(entityName: UploadDataRecord.entityName)
        return coreData.fetch(withRequest: request)
    }

    /// Removes stale data based on size or date, if they're limited in options.
    @discardableResult public func clearStaleDataIfNeeded() -> UInt {
        guard options.cacheDaysLimit > 0 else {
            return 0
        }

        let now = Date().timeIntervalSince1970
        let lastValidTime = now - TimeInterval(options.cacheDaysLimit * 86400) // (60 * 60 * 24) = 86400 seconds per day
        let recordsToDelete = fetchRecordsToDelete(dateLimit: Date(timeIntervalSince1970: lastValidTime))
        let deleteCount = recordsToDelete.count

        if deleteCount > 0 {
            let span = EmbraceOTel().buildSpan(
                name: "emb-upload-cache-vacuum",
                type: .performance,
                attributes: ["removed": "\(deleteCount)"])
                .markAsPrivate()
            span.setStartTime(time: Date())

            let startedSpan = span.startSpan()
            coreData.deleteRecords(recordsToDelete)
            startedSpan.end()

            return UInt(deleteCount)
        }

        return 0
    }

    /// Saves the given upload data to the cache.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    ///   - data: Data to cache
    /// - Returns: Boolean indicating if the operation was successful
    @discardableResult func saveUploadData(id: String, type: EmbraceUploadType, data: Data) -> Bool {

        // update if it already exists
        if let record = fetchUploadData(id: id, type: type) {
            coreData.context.performAndWait { [weak self] in
                record.data = data
                self?.coreData.save()
            }

            return true
        }

        // check limit and delete if necessary
        checkCountLimit()

        // insert new
        var result = true

        coreData.context.performAndWait {
            if let record = UploadDataRecord.create(
                context: coreData.context,
                id: id,
                type: type.rawValue,
                data: data,
                attemptCount: 0,
                date: Date()
            ) {

                do {
                    try coreData.context.save()
                } catch {
                    coreData.context.delete(record)
                    result = false
                }
            } else {
                result = false
            }
        }

        return result
    }

    // Checks the amount of records stored and deletes the oldest ones if the total amount
    // surpasses the limit.
    func checkCountLimit() {
        guard options.cacheLimit > 0 else {
            return
        }

        coreData.context.performAndWait { [weak self] in
            guard let strongSelf = self else {
                return
            }

            do {
                let request = NSFetchRequest<UploadDataRecord>(entityName: UploadDataRecord.entityName)
                let count = try strongSelf.coreData.context.count(for: request)

                if count >= strongSelf.options.cacheLimit {
                    request.sortDescriptors = [NSSortDescriptor(key: "date", ascending: true)]
                    request.fetchLimit = max(0, count - Int(strongSelf.options.cacheLimit) + 10)

                    let result = try strongSelf.coreData.context.fetch(request)
                    for uploadData in result {
                        strongSelf.coreData.context.delete(uploadData)
                    }

                    strongSelf.coreData.save()
                }
            } catch { }
        }
    }

    /// Deletes the cached data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    func deleteUploadData(id: String, type: EmbraceUploadType) {
        guard let uploadData = fetchUploadData(id: id, type: type) else {
            return
        }

        coreData.deleteRecord(uploadData)
    }

    /// Updates the attempt count of the upload data for the given identifier.
    /// - Parameters:
    ///   - id: Identifier of the data
    ///   - type: Type of the data
    ///   - attemptCount: New attempt count
    /// - Returns: Returns the updated `UploadDataRecord`, if any
    func updateAttemptCount(
        id: String,
        type: EmbraceUploadType,
        attemptCount: Int
    ) {
        guard let uploadData = fetchUploadData(id: id, type: type) else {
            return
        }

        coreData.context.performAndWait { [weak self] in
            uploadData.attemptCount = attemptCount
            self?.coreData.save()
        }
    }

    /// Fetches all records that should be deleted based on them being older than the passed date
    func fetchRecordsToDelete(dateLimit: Date) -> [UploadDataRecord] {
        let request = NSFetchRequest<UploadDataRecord>(entityName: UploadDataRecord.entityName)
        request.predicate = NSPredicate(format: "date < %@", dateLimit as NSDate)

        return coreData.fetch(withRequest: request)
    }
}
