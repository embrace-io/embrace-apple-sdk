#!/usr/bin/env bash
set -Eeuo pipefail

# -------------------- CONFIG --------------------
: "${TESTS:=EmbraceIOTests/PerformanceTests}"
WORKSPACE=".swiftpm/xcode/package.xcworkspace"
SCHEME="EmbraceIO-Package"
DESTINATION="platform=iOS Simulator,name=iPhone 16 Pro"
: "${SHOULD_CLEAN:=1}"
: "${ITERATIONS:=10}"
# ------------------------------------------------
PRE_ACTIONS="clean build-for-testing"
if (( SHOULD_CLEAN != 1 )); then
  PRE_ACTIONS="build-for-testing"
fi

# collect tests
IFS=$'\n' read -r -d '' -a TESTS <<< "${TESTS}" || true

TEST_ARGS=()
for t in "${TESTS[@]}"; do
    TEST_ARGS+=("-only-testing:${t}")
done

# Log helper (stderr so JSON stays clean)
log() { printf '%s\n' "$*" >&2; }

if ! [[ "$ITERATIONS" =~ ^[0-9]+$ ]]; then
  log "ERROR: ITERATIONS must be an integer"
  exit 1
fi

if (( ITERATIONS < 1 )); then
  log "ERROR: ITERATIONS must be at least 1"
  exit 1
fi

# always add an iteration that we can discard later.
ITERATIONS=$((ITERATIONS + 1))

# Temp dir for intermediate results
TMPDIR_ROOT="$(mktemp -d -t perf-run-XXXXXX)"
RESULT_FILE="${TMPDIR_ROOT}/TestResults.xcresult"

run_quiet() {
    local out status
    out=$(mktemp) || { echo "mktemp failed" >&2; return 2; }

    # Run the command/pipeline in a subshell with pipefail
    ( set -o pipefail; "$@" ) >"$out" 2>&1
    status=$?

    if [ $status -ne 0 ]; then
        # On failure: dump everything to stderr
        cat "$out" >&2
        rm -f "$out"
        return $status
    fi

    # On success: replay stdout (caller can redirect if they want silence)
    cat "$out"
    rm -f "$out"
    return 0
}

cleanup() {
  # remove temp artifacts; keep final bundle if it exists
  rm -rf "${TMPDIR_ROOT}"
}
trap cleanup EXIT
trap 'exit 130' INT QUIT  # 130 = terminated by Ctrl-C/QUIT

log "Starting performance tests, ${TESTS[*]}"

# Start clean
rm -rf "${TMPDIR_ROOT}" >/dev/null 2>&1 || true

log "${PRE_ACTIONS} test bundle for '${DESTINATION}'â€¦"
run_quiet xcodebuild ${PRE_ACTIONS} \
  -workspace "${WORKSPACE}" \
  -scheme "${SCHEME}" \
  -destination "${DESTINATION}" \
  >/dev/null


  log "Testing with $((ITERATIONS - 1)) iteration(s)..."
  run_quiet xcodebuild test-without-building \
    -workspace "${WORKSPACE}" \
    -scheme "${SCHEME}" \
    "${TEST_ARGS[@]}" \
    -destination "${DESTINATION}" \
    -resultBundlePath "${RESULT_FILE}" \
    -test-iterations "${ITERATIONS}" \
    -skipPackageUpdates \
    -skipPackagePluginValidation \
    -skipMacroValidation \
    -disableAutomaticPackageResolution \
    >/dev/null

# we could use `xcrun xcresulttool get test-results metrics`,
# or `xcresultparser`, but both complicate things. 
# For option 1, we need the test to have a `measure{}` in it
# which most don't. Maybe someday we'll optimize for that.

# Also, we're skipping the first iteration as a warm-up.

log "Crunching results..."
run_quiet xcrun xcresulttool get test-results tests \
       --path "${RESULT_FILE}" \
       --format json \
        | jq '
  [ .. | objects | select(.nodeType? == "Test Case")
    | . as $tc
    | ([$tc | .. | objects | select(.nodeType? == "Repetition") | .durationInSeconds]) as $all
    | ($all[1:]) as $rest
    | ($rest | length) as $n
    | ($rest | (if $n>0 then add/$n else null end)) as $avg
    | ($rest | sort) as $sorted
    | (if $n>0 then
         (if ($n % 2)==1
            then $sorted[($n/2|floor)]
            else ($sorted[($n/2-1)] + $sorted[$n/2]) / 2
          end)
       else null end) as $median
    | (if $n>0 then
         ( ($rest | map((. - $avg) * (. - $avg)) | add) / $n | sqrt )
       else null end) as $stddev
    | {
        name:    $tc.name,
        result:  $tc.result,
        min:     (if $n>0 then ($rest | min) else null end),
        max:     (if $n>0 then ($rest | max) else null end),
        avg:     $avg,
        median:  $median,
        stddev:  $stddev,
        count:   $n
      }
  ]'
