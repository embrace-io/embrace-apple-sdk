#!/usr/bin/env bash
set -Eeuo pipefail

# Load the function
source "${EMB_BIN_HOME}/destinations"

# Log helper (stderr so JSON stays clean)
log() { printf '%s\n' "$*" >&2; }

log ">> PERF"

# -------------------- CONFIG --------------------
: "${TESTS:=EmbraceIOTests/PerformanceTests}"
WORKSPACE=".swiftpm/xcode/package.xcworkspace"
SCHEME="EmbraceIO-Package"
: "${SHOULD_CLEAN:=1}"
: "${ITERATIONS:=10}"
# ------------------------------------------------
PRE_ACTIONS="clean build-for-testing"
if (( SHOULD_CLEAN != 1 )); then
  PRE_ACTIONS="build-for-testing"
fi

DESTINATION=$(get_best_id_arch "${WORKSPACE}" "${SCHEME}" "iPhone~Pro" "iOS Simulator" "~")
UDID=$(get_best_id "${WORKSPACE}" "${SCHEME}" "iPhone~Pro" "iOS Simulator" "~")

echo "Using destination: ${DESTINATION}" >&2
echo "Using UDID: ${UDID}" >&2

if [ ! -d "${WORKSPACE}" ]; then
  log "${WORKSPACE} workspace does not exist, skipping."
  # you can exit or create one here
  exit 0
fi

boot_sim "${UDID}"

# collect tests
IFS=$'\n' read -r -d '' -a TESTS <<< "${TESTS}" || true

TEST_ARGS=()
for t in "${TESTS[@]}"; do
    TEST_ARGS+=("-only-testing:${t}")
done

if ! [[ "$ITERATIONS" =~ ^[0-9]+$ ]]; then
  log "ERROR: ITERATIONS must be an integer"
  exit 1
fi

if (( ITERATIONS < 1 )); then
  log "ERROR: ITERATIONS must be at least 1"
  exit 1
fi

# always add an iteration that we can discard later.
ITERATIONS=$((ITERATIONS + 1))

# Temp dir for intermediate results
TMPDIR_ROOT="$(mktemp -d -t perf-run-XXXXXX)"
RESULT_FILE="${TMPDIR_ROOT}/TestResults.xcresult"

run_quiet() {
    local out status
    out=$(mktemp) || { echo "mktemp failed" >&2; return 2; }

    # Run the command/pipeline in a subshell with pipefail
    ( set -o pipefail; "$@" ) >"$out" 2>&1
    status=$?

    if [ $status -ne 0 ]; then
        # On failure: dump everything to stderr
        cat "$out" >&2
        rm -f "$out"
        return $status
    fi

    # On success: replay stdout (caller can redirect if they want silence)
    cat "$out"
    rm -f "$out"
    return 0
}

cleanup() {
  # remove temp artifacts; keep final bundle if it exists
  rm -rf "${TMPDIR_ROOT}"
}
trap cleanup EXIT
trap 'exit 130' INT QUIT  # 130 = terminated by Ctrl-C/QUIT

log "Starting performance tests, ${TESTS[*]}"

# Start clean
rm -rf "${TMPDIR_ROOT}" >/dev/null 2>&1 || true

log "${PRE_ACTIONS} test bundle for '${DESTINATION}'â€¦"
xcodebuild ${PRE_ACTIONS} \
  -workspace "${WORKSPACE}" \
  -scheme "${SCHEME}" \
  -destination "${DESTINATION}" \
  | xcpretty >&2

log "Running a few warm-up iterations..."
xcodebuild test-without-building \
  -workspace "${WORKSPACE}" \
  -scheme "${SCHEME}" \
  "${TEST_ARGS[@]}" \
  -destination "${DESTINATION}" \
  -test-iterations 3 \
  | xcpretty >&2

log "Testing with $((ITERATIONS - 1)) iteration(s)..."
run_quiet xcodebuild test-without-building \
  -workspace "${WORKSPACE}" \
  -scheme "${SCHEME}" \
  "${TEST_ARGS[@]}" \
  -destination "${DESTINATION}" \
  -resultBundlePath "${RESULT_FILE}" \
  -test-iterations "${ITERATIONS}" \
  | xcpretty >&2

log "Crunching results..."
run_quiet xcrun xcresulttool get test-results tests \
       --path "${RESULT_FILE}" \
       --format json \
        | jq '
  [ .. | objects | select(.nodeType? == "Test Case")
    | . as $tc
    | ([$tc | .. | objects | select(.nodeType? == "Repetition") | .durationInSeconds]) as $all
    | ($all[1:]) as $rest
    | ($rest | length) as $n
    | ($rest | (if $n>0 then add/$n else null end)) as $avg
    | ($rest | sort) as $sorted
    | (if $n>0 then
         (if ($n % 2)==1
            then $sorted[($n/2|floor)]
            else ($sorted[($n/2-1)] + $sorted[$n/2]) / 2
          end)
       else null end) as $median
    | (if $n>0 then
         ( ($rest | map((. - $avg) * (. - $avg)) | add) / $n | sqrt )
       else null end) as $stddev
    | {
        name:    $tc.name,
        result:  $tc.result,
        min:     (if $n>0 then ($rest | min) else null end),
        max:     (if $n>0 then ($rest | max) else null end),
        avg:     $avg,
        median:  $median,
        stddev:  $stddev,
        count:   $n,
        all:     $rest
      }
  ]'
