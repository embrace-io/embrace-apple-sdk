#!/usr/bin/env bash
set -Eeuo pipefail

boot_sim() {
  local UDID="${1:?usage: boot_sim <udid> [timeout=120] [--launch]}"
  local TIMEOUT="${2:-60}"
  local INTERVAL=1
  local elapsed=0

  echo "[boot_sim] Target: $UDID (timeout ${TIMEOUT}s)" >&2

  echo "[boot_sim] Launching Simulator.app..." >&2
  open -ga Simulator --args -CurrentDeviceUDID "$UDID" || true

  echo "[boot_sim] Booting…" >&2
  #xcrun simctl boot "$UDID" --arch=arm64 >/dev/null >&2 || true
  local boot
  boot="$(xcrun simctl boot "$UDID" --arch=arm64 2>&1)"
  echo "[boot_sim] Boot output: $boot" >&2

  if [[ "$boot" == *"current state: Booted"* ]]; then
    echo "[boot_sim] Booted." >&2
    exit 0
  fi

  # maybe check for Unable to boot device in current state: Booted

  echo "[boot_sim] Waiting for bootstatus to succeed…" >&2
  while (( elapsed < TIMEOUT )); do
    local out
    if out="$(gtimeout $INTERVAL xcrun simctl bootstatus "$UDID" >/dev/null)"; then
      echo "[boot_sim] Booted." >&2
      return 0
    else
      echo "[boot_sim] ...booting" >&2
    fi
    (( elapsed += INTERVAL ))
  done

  echo "[boot_sim] Timeout after ${TIMEOUT}s waiting for bootstatus to succeed." >&2
  return 124
}



# Destinations script for finding and scoring iOS simulators
# Provides sophisticated device selection with fuzzy matching and version-aware scoring

get_best_id() {
  local container="$1"
  local scheme="$2"
  local name="$3"
  local os="$4"
  local ver="$5"

  get_sim "$container" "$scheme" "$name" "$os" "$ver" 1 \
    | jq -r '.[0].id // empty'
}

get_best_id_arch() {
  local container="$1"
  local scheme="$2"
  local name="$3"
  local os="$4"
  local ver="$5"

  get_sim "$container" "$scheme" "$name" "$os" "$ver" 1 \
    | jq -r '.[0] | "id=\(.id),arch=\(.arch)" // empty'
}

get_best_destination() {
  local container="$1"
  local scheme="$2"
  local name="$3"
  local os="$4"
  local ver="$5"

  get_sim "$container" "$scheme" "$name" "$os" "$ver" 1 \
    | jq -r '.[0].destination // empty'
}

# Usage:
#   param 1: .xcworkspace or .xcodeproj
#   param 2: scheme
#   param 3: device name (e.g. "iPhone 14 Pro", "~iPhone", or "" for any)
#   param 4: OS platform (e.g. "iOS", "~iOS", or "" for any)
#   param 5: OS version (e.g. "17.0", "~17", or "" for any)

get_sim() {
  local container="$1"   # .xcworkspace or .xcodeproj
  local scheme="$2"
  local name="$3"
  local os="$4"
  local ver="$5"
  local limit="${6:-1}"   # default: 1

  # Check for wildcard patterns and mark fuzzy flags
  local nameFuzzy=0 osFuzzy=0 verFuzzy=0
  if [[ "$name" == *~* ]]; then nameFuzzy=1; fi
  if [[ "$os"   == *~* ]]; then osFuzzy=1;   fi
  if [[ "$ver"  == *~* ]]; then verFuzzy=1;  fi

  # Figure out which flag to use for xcodebuild
  local flag
  case "$container" in
    *.xcworkspace) flag="-workspace" ;;
    *.xcodeproj)   flag="-project"   ;;
    *) echo "Unknown container type: $container" >&2; return 2 ;;
  esac

    # Run xcodebuild -showdestinations and convert to JSON
  local json
  json="$(
    xcodebuild "$flag" "$container" -scheme "$scheme" -showdestinations 2>/dev/null \
    | sed -n 's/.*platform:\([^,}]*\).*arch:\([^,}]*\).*id:\([^,}]*\).*OS:\([^,}]*\).*name:\([^}]*\).*/{"platform":"\1","arch":"\2","id":"\3","os":"\4","name":"\5"}/p' \
    | jq -s .
  )"

jq -r \
  --arg NAME "$name" \
  --arg OS "$os" \
  --arg VER "$ver" \
  --argjson NAME_FUZZY "$nameFuzzy" \
  --argjson OS_FUZZY "$osFuzzy" \
  --argjson VER_FUZZY "$verFuzzy" \
  --argjson LIMIT "$limit" '
    def trim: gsub("^[[:space:]]+|[[:space:]]+$";"");
    def down: ascii_downcase;
    def eqi($b):        (.|tostring|trim|down) == ($b|tostring|trim|down);
    def containsi($b):  (.|tostring|trim|down) | contains($b|tostring|trim|down);
    def wildcard_match($pattern):
      (.|tostring|trim|down) as $text |
      ($pattern|tostring|trim|down) as $pat |
      if ($pat | contains("~")) then
        # Convert pattern to regex by escaping special chars except ~, then replace ~ with .*
        ($pat | gsub("[.+*?^${}()|\\[\\]]"; "\\\\&") | gsub("~"; ".*")) as $regex |
        ($text | test("^" + $regex + "$"))
      else
        $text == $pat
      end;

    # Compute per-candidate score (exact > fuzzy). Penalize non-matches hard.
    def score($N; $NF; $O; $OF; $V; $VF):
      (if $N == "" then 0
       elif $NF == 0 then if (.name // "")     | eqi($N)           then 30 else -1000 end
       else                 if (.name // "")     | wildcard_match($N) then 15
                            elif (.name // "")   | containsi($N)     then 10 else -1000 end end)
      +
      (if $O == "" then 0
       elif $OF == 0 then if (.platform // "") | eqi($O)           then 20 else -1000 end
       else                 if (.platform // "") | wildcard_match($O) then 8
                            elif (.platform // "") | containsi($O)     then  5 else -1000 end end)
      +
      (if $V == "" then 0
       elif $VF == 0 then if (.os // "") == ($VER|trim)         then 20 else -1000 end
       else                 if (.os // "") | wildcard_match($V) then 12
                            elif (.os // "") | startswith($VER|trim)
                              or ((.os // "") | contains($VER|trim)) then 8 else -1000 end end)
      +
      (if (.arch? // "") == "arm64" then 2 else 0 end)
    ;

    [ .[]
      | select(.name != "Any iOS Simulator Device")
      # normalize/trim all fields first
      | .platform = (.platform // "" | trim)
      | .arch     = (.arch?    // "" | trim)
      | .id       = (.id       // "" | trim)
      | .os       = (.os       // "" | trim)
      | .name     = (.name     // "" | trim)
      | .ver_nums   = ((.os // "0") | split(".") | map(tonumber? // 0))
      | .score      = score($NAME; $NAME_FUZZY; $OS; $OS_FUZZY; $VER; $VER_FUZZY)
      | .destination = ("platform=" + .platform + ",arch=" + .arch + ",id=" + .id + ",OS=" + .os + ",name=" + .name)
      | .smurf = ("{ platform:" + .platform + ", arch:" + .arch + ", id:" + .id + ",OS:" + .os + ", name:" + .name + " }")
    ]
    | map(select(.score > -1000))
    | sort_by([.id, .score, .ver_nums]) | group_by(.id) | map(.[-1])   # best per UDID
    | sort_by([.score, .ver_nums]) | reverse
    | .[:$LIMIT]
    | map(del(.ver_nums, .score))
' <<<"$json"
}

